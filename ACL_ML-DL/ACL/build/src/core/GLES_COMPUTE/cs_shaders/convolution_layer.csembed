R"(

/*
 * Copyright (c) 2017-2018 ARM Limited.
 *
 * SPDX-License-Identifier: MIT
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

layout(local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y, local_size_z = LOCAL_SIZE_Z) in;

/*
 * Copyright (c) 2017-2018 ARM Limited.
 *
 * SPDX-License-Identifier: MIT
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef ARM_COMPUTE_HELPER_CS_H
#define ARM_COMPUTE_HELPER_CS_H

#define SHADER_PARAMS_DECLARATION \
    layout(std140, binding = 0) uniform shader_params

#define TENSOR_DECLARATION(location, buffer_type, type, ptr_name, shift_name, element_shift, access) \
    layout(std430, binding = location) access buffer buffer_type                                     \
    {                                                                                                \
        type ptr_name[];                                                                             \
    };                                                                                               \
    const uint shift_name = uint(element_shift)

struct VectorAttributes
{
    uint stride_x;                      /**< Stride of the vector in X dimension (in bytes) */
    uint step_x;                        /**< stride_x * number of elements along X processed per workitem (in bytes) */
    uint offset_first_element_in_bytes; /**< The offset of the first element in the vector (in bytes) */
    uint padding;                       /**< The padding to rounding up the structure to a multiple of a vec4 */
};

struct ImageAttributes
{
    uint stride_x;                      /**< Stride of the image in X dimension (in bytes) */
    uint step_x;                        /**< stride_x * number of elements along X processed per workitem (in bytes) */
    uint stride_y;                      /**< Stride of the image in Y dimension (in bytes) */
    uint step_y;                        /**< stride_y * number of elements along Y processed per workitem (in bytes) */
    uint offset_first_element_in_bytes; /**< The offset of the first element in the image (in bytes) */
    uint padding1;                      /**< The padding to rounding up the structure to a multiple of a vec4 */
    uint padding2;                      /**< The padding to rounding up the structure to a multiple of a vec4 */
    uint padding3;                      /**< The padding to rounding up the structure to a multiple of a vec4 */
};

struct Tensor3DAttributes
{
    uint stride_x;                      /**< Stride of the tensor in X dimension (in bytes) */
    uint step_x;                        /**< stride_x * number of elements along X processed per workitem (in bytes) */
    uint stride_y;                      /**< Stride of the tensor in Y dimension (in bytes) */
    uint step_y;                        /**< stride_y * number of elements along Y processed per workitem (in bytes) */
    uint stride_z;                      /**< Stride of the tensor in Z dimension (in bytes) */
    uint step_z;                        /**< stride_z * number of elements along Z processed per workitem (in bytes) */
    uint offset_first_element_in_bytes; /**< The offset of the first element in the tensor (in bytes) */
    uint padding;                       /**< The padding to rounding up the structure to a multiple of a vec4 */
};

struct VectorIterator
{
    int current_offset_in_bytes; /**< Current offset of vector (in bytes) */
    int stride_x;                /**< Stride of the vector in X dimension (in bytes) */
    int element_shift;           /**< The number of bits to shift by for one element */
};

struct ImageIterator
{
    int current_offset_in_bytes; /**< Current offset of image (in bytes) */
    int stride_x;                /**< Stride of the image in X dimension (in bytes) */
    int stride_y;                /**< Stride of the image in Y dimension (in bytes) */
    int element_shift;           /**< The number of bits to shift by for one element */
};

struct Tensor3DIterator
{
    int current_offset_in_bytes; /**< Current offset of tensor (in bytes) */
    int stride_x;                /**< Stride of the tensor in X dimension (in bytes) */
    int stride_y;                /**< Stride of the tensor in Y dimension (in bytes) */
    int stride_z;                /**< Stride of the tensor in Z dimension (in bytes) */
    int element_shift;           /**< The number of bits to shift by for one element */
};

#define CONVERT_TO_VECTOR_ITERATOR(attrs, element_shift)                          \
    update_vector_iter_offset(element_shift, attrs.offset_first_element_in_bytes, \
                              attrs.stride_x, attrs.step_x)

#define CONVERT_TO_VECTOR_ITERATOR_NO_STEP(attrs, element_shift)                  \
    update_vector_iter_offset(element_shift, attrs.offset_first_element_in_bytes, \
                              attrs.stride_x, uint(0))

#define CONVERT_TO_IMAGE_ITERATOR(attrs, element_shift)                          \
    update_image_iter_offset(element_shift, attrs.offset_first_element_in_bytes, \
                             attrs.stride_x, attrs.step_x, attrs.stride_y, attrs.step_y)

#define CONVERT_TO_IMAGE_ITERATOR_NO_STEP(attrs, element_shift)                  \
    update_image_iter_offset(element_shift, attrs.offset_first_element_in_bytes, \
                             attrs.stride_x, uint(0), attrs.stride_y, uint(0))

#define CONVERT_TO_TENSOR3D_ITERATOR(attrs, element_shift)                          \
    update_tensor3D_iter_offset(element_shift, attrs.offset_first_element_in_bytes, \
                                attrs.stride_x, attrs.step_x, attrs.stride_y, attrs.step_y, attrs.stride_z, attrs.step_z)

#define CONVERT_TO_TENSOR3D_ITERATOR_NO_STEP(attrs, element_shift)                  \
    update_tensor3D_iter_offset(element_shift, attrs.offset_first_element_in_bytes, \
                                attrs.stride_x, uint(0), attrs.stride_y, uint(0), attrs.stride_z, uint(0))

#define CONVERT_TENSOR3D_TO_IMAGE_ITERATOR(attrs, element_shift)                               \
    update_image_from_tensor3D_iter_offset(element_shift, attrs.offset_first_element_in_bytes, \
                                           attrs.stride_x, attrs.step_x, attrs.stride_y, attrs.step_y, attrs.stride_z, attrs.step_z)

#define CONVERT_TENSOR3D_TO_IMAGE_ITERATOR_NO_STEP(attrs, element_shift)                       \
    update_image_from_tensor3D_iter_offset(element_shift, attrs.offset_first_element_in_bytes, \
                                           attrs.stride_x, uint(0), attrs.stride_y, uint(0), attrs.stride_z, attrs.step_z)

/** Wrap vector information into a VectorIterator structure, and make the offset to be this workitem's position.
 *
 * @param[in] element_shift                 The number of bits to shift by for one element
 * @param[in] offset_first_element_in_bytes The offset of the first element in the source vector
 * @param[in] stride_x                      Stride of the vector in X dimension (in bytes)
 * @param[in] step_x                        stride_x * number of elements along X processed per workitem (in bytes)
 *
 * @return A VectorIterator object
 */
VectorIterator update_vector_iter_offset(uint element_shift, uint offset_first_element_in_bytes, uint stride_x, uint step_x)
{
    VectorIterator vector_iter;
    vector_iter.element_shift           = int(element_shift);
    vector_iter.stride_x                = int(stride_x);
    vector_iter.current_offset_in_bytes = int(offset_first_element_in_bytes + gl_GlobalInvocationID.x * step_x);

    return vector_iter;
}

/** Wrap image information into an ImageIterator structure, and make the offset to be this workitem's position.
 *
 * @param[in] element_shift                 The number of bits to shift by for one element
 * @param[in] offset_first_element_in_bytes The offset of the first element in the source image
 * @param[in] stride_x                      Stride of the image in X dimension (in bytes)
 * @param[in] step_x                        stride_x * number of elements along X processed per workitem (in bytes)
 * @param[in] stride_y                      Stride of the image in Y dimension (in bytes)
 * @param[in] step_y                        stride_y * number of elements along Y processed per workitem (in bytes)
 *
 * @return An ImageIterator object
 */
ImageIterator update_image_iter_offset(uint element_shift, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y)
{
    ImageIterator image_iter;
    image_iter.element_shift           = int(element_shift);
    image_iter.stride_x                = int(stride_x);
    image_iter.stride_y                = int(stride_y);
    image_iter.current_offset_in_bytes = int(offset_first_element_in_bytes + gl_GlobalInvocationID.x * step_x + gl_GlobalInvocationID.y * step_y);

    return image_iter;
}

/** Wrap 3D tensor information into a Tensor3DIterator structure, and make the offset to be this workitem's position.
 *
 * @param[in] element_shift                 The number of bits to shift by for one element
 * @param[in] offset_first_element_in_bytes The offset of the first element in the source tersor
 * @param[in] stride_x                      Stride of the tersor in X dimension (in bytes)
 * @param[in] step_x                        stride_x * number of elements along X processed per workitem (in bytes)
 * @param[in] stride_y                      Stride of the tersor in Y dimension (in bytes)
 * @param[in] step_y                        stride_y * number of elements along Y processed per workitem (in bytes)
 * @param[in] stride_z                      Stride of the tersor in Z dimension (in bytes)
 * @param[in] step_z                        stride_z * number of elements along Z processed per workitem (in bytes)
 *
 * @return A 3D Tensor3DIterator object
 */
Tensor3DIterator update_tensor3D_iter_offset(uint element_shift, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)
{
    Tensor3DIterator tensor_iter;
    tensor_iter.element_shift           = int(element_shift);
    tensor_iter.stride_x                = int(stride_x);
    tensor_iter.stride_y                = int(stride_y);
    tensor_iter.stride_z                = int(stride_z);
    tensor_iter.current_offset_in_bytes = int(offset_first_element_in_bytes + gl_GlobalInvocationID.x * step_x + gl_GlobalInvocationID.y * step_y + gl_GlobalInvocationID.z * step_z);

    return tensor_iter;
}

/** Wrap 3D tensor information into an ImageIterator structure, and make the offset to be this workitem's position.
 *
 * @param[in] element_shift                 The number of bits to shift by for one element
 * @param[in] offset_first_element_in_bytes The offset of the first element in the source tensor
 * @param[in] stride_x                      Stride of the tensor in X dimension (in bytes)
 * @param[in] step_x                        stride_x * number of elements along X processed per workitem (in bytes)
 * @param[in] stride_y                      Stride of the tensor in Y dimension (in bytes)
 * @param[in] step_y                        stride_y * number of elements along Y processed per workitem (in bytes)
 * @param[in] stride_z                      Stride of the tensor in Z dimension (in bytes)
 * @param[in] step_z                        stride_z * number of elements along Z processed per workitem (in bytes)
 *
 * @return An ImageIterator object
 */
ImageIterator update_image_from_tensor3D_iter_offset(uint element_shift, uint offset_first_element_in_bytes, uint stride_x, uint step_x, uint stride_y, uint step_y, uint stride_z, uint step_z)
{
    ImageIterator image_iter;
    image_iter.element_shift           = int(element_shift);
    image_iter.stride_x                = int(stride_x);
    image_iter.stride_y                = int(stride_y);
    image_iter.current_offset_in_bytes = int(offset_first_element_in_bytes + gl_GlobalInvocationID.x * step_x + gl_GlobalInvocationID.y * step_y + gl_GlobalInvocationID.z * step_z);

    return image_iter;
}

#define VECTOR_OFFSET(tensor_iter, x) \
    uint(vector_offset_in_bytes(tensor_iter, int(x)) >> tensor_iter.element_shift)

#define IMAGE_OFFSET(tensor_iter, x, y) \
    uint(image_offset_in_bytes(tensor_iter, int(x), int(y)) >> tensor_iter.element_shift)

#define TENSOR3D_OFFSET(tensor_iter, x, y, z) \
    uint(tensor3D_offset_in_bytes(tensor_iter, int(x), int(y), int(z)) >> tensor_iter.element_shift)

#define TENSOR_OFFSET_ADVANCE(tensor_iter, n) \
    uint((tensor_iter.current_offset_in_bytes >> tensor_iter.element_shift) + int(n))

#define TENSOR_OFFSET_ADVANCE_IN_BYTES(tensor_iter, n) \
    uint((tensor_iter.current_offset_in_bytes + int(n)) >> tensor_iter.element_shift)

#define CURRENT_ITEM_OFFSET(tensor_iter) \
    uint(tensor_iter.current_offset_in_bytes >> tensor_iter.element_shift)

#define CURRENT_ITEM_OFFSET_IN_BYTES(tensor_iter) \
    uint(tensor_iter.current_offset_in_bytes)

#define TENSOR_ITERATOR_ADVANCE(tensor_iter, n) \
    tensor_iter.current_offset_in_bytes += (int(n) << tensor_iter.element_shift)

#define TENSOR_ITERATOR_ADVANCE_IN_BYTES(tensor_iter, n) \
    tensor_iter.current_offset_in_bytes += int(n)

#define SET_TENSOR_ITERATOR_OFFSET_IN_BYTES(tensor_iter, n) \
    tensor_iter.current_offset_in_bytes = int(n)

/** Get the offset of a VectorIterator
 *
 * @param[in] vector_iter The VectorIterator object pointed to the starting position of the buffer
 * @param[in] x           Relative X position
 *
 * @return The relative offset of the VectorIterator object (in bytes)
 */
uint vector_offset_in_bytes(VectorIterator vector_iter, int x)
{
    return uint(vector_iter.current_offset_in_bytes + x * vector_iter.stride_x);
}

/** Get the offset of an ImageIterator
 *
 * @param[in] vector_iter The ImageIterator object pointed to the starting position of the buffer
 * @param[in] x           Relative X position
 * @param[in] y           Relative Y position
 *
 * @return The relative offset of the ImageIterator object (in bytes)
 */
uint image_offset_in_bytes(ImageIterator image_iter, int x, int y)
{
    return uint(image_iter.current_offset_in_bytes + x * image_iter.stride_x + y * image_iter.stride_y);
}

/** Get the offset of a Tensor3DIterator
 *
 * @param[in] vector_iter The Tensor3DIterator object pointed to the starting position of the buffer
 * @param[in] x           Relative X position
 * @param[in] y           Relative Y position
 * @param[in] z           Relative Z position
 *
 * @return The relative offset of the Tensor3DIterator object (in bytes)
 */
uint tensor3D_offset_in_bytes(Tensor3DIterator tensor_iter, int x, int y, int z)
{
    return uint(tensor_iter.current_offset_in_bytes + x * tensor_iter.stride_x + y * tensor_iter.stride_y + z * tensor_iter.stride_z);
}

#define LOAD(tensor_ptr, offset) tensor_ptr[offset]
#define STORE(tensor_ptr, offset, data) tensor_ptr[offset] = data
#define LOAD_CURRENT_ITEM(tensor_ptr, tensor_iter) tensor_ptr[CURRENT_ITEM_OFFSET(tensor_iter)]
#define STORE_CURRENT_ITEM(tensor_ptr, tensor_iter, data) tensor_ptr[CURRENT_ITEM_OFFSET(tensor_iter)] = data

#define VLOAD2(return_type, tensor_ptr, offset) \
    return_type(LOAD(tensor_ptr, offset),       \
                LOAD(tensor_ptr, (offset) + uint(1)))

#define VSTORE2(tensor_ptr, offset, data) \
    STORE(tensor_ptr, offset, data[0]);   \
    STORE(tensor_ptr, (offset) + uint(1), data[1])

#define VLOAD2_CURRENT_ITEM(return_type, tensor_ptr, tensor_iter) VLOAD2(return_type, tensor_ptr, CURRENT_ITEM_OFFSET(tensor_iter))
#define VSTORE2_CURRENT_ITEM(tensor_ptr, tensor_iter, data) VSTORE2(tensor_ptr, CURRENT_ITEM_OFFSET(tensor_iter), data)

#define VLOAD3(return_type, tensor_ptr, offset)       \
    return_type(LOAD(tensor_ptr, offset),             \
                LOAD(tensor_ptr, (offset) + uint(1)), \
                LOAD(tensor_ptr, (offset) + uint(2)))

#define VSTORE3(tensor_ptr, offset, data)           \
    STORE(tensor_ptr, offset, data[0]);             \
    STORE(tensor_ptr, (offset) + uint(1), data[1]); \
    STORE(tensor_ptr, (offset) + uint(2), data[2])

#define VLOAD3_CURRENT_ITEM(return_type, tensor_ptr, tensor_iter) VLOAD3(return_type, tensor_ptr, CURRENT_ITEM_OFFSET(tensor_iter))
#define VSTORE3_CURRENT_ITEM(tensor_ptr, tensor_iter, data) VSTORE3(tensor_ptr, CURRENT_ITEM_OFFSET(tensor_iter), data)

#define VLOAD4(return_type, tensor_ptr, offset)       \
    return_type(LOAD(tensor_ptr, offset),             \
                LOAD(tensor_ptr, (offset) + uint(1)), \
                LOAD(tensor_ptr, (offset) + uint(2)), \
                LOAD(tensor_ptr, (offset) + uint(3)))

#define VSTORE4(tensor_ptr, offset, data)           \
    STORE(tensor_ptr, offset, data[0]);             \
    STORE(tensor_ptr, (offset) + uint(1), data[1]); \
    STORE(tensor_ptr, (offset) + uint(2), data[2]); \
    STORE(tensor_ptr, (offset) + uint(3), data[3])

#define VLOAD4_CURRENT_ITEM(return_type, tensor_ptr, tensor_iter) VLOAD4(return_type, tensor_ptr, CURRENT_ITEM_OFFSET(tensor_iter))
#define VSTORE4_CURRENT_ITEM(tensor_ptr, tensor_iter, data) VSTORE4(tensor_ptr, CURRENT_ITEM_OFFSET(tensor_iter), data)

#define VLOAD5(return_type, tensor_ptr, offset)       \
    return_type(LOAD(tensor_ptr, offset),             \
                LOAD(tensor_ptr, (offset) + uint(1)), \
                LOAD(tensor_ptr, (offset) + uint(2)), \
                LOAD(tensor_ptr, (offset) + uint(3)), \
                LOAD(tensor_ptr, (offset) + uint(4)))

#define VSTORE5(tensor_ptr, offset, data)           \
    STORE(tensor_ptr, offset, data[0]);             \
    STORE(tensor_ptr, (offset) + uint(1), data[1]); \
    STORE(tensor_ptr, (offset) + uint(2), data[2]); \
    STORE(tensor_ptr, (offset) + uint(3), data[3]); \
    STORE(tensor_ptr, (offset) + uint(4), data[4])

#define VLOAD5_CURRENT_ITEM(return_type, tensor_ptr, tensor_iter) VLOAD5(return_type, tensor_ptr, CURRENT_ITEM_OFFSET(tensor_iter))
#define VSTORE5_CURRENT_ITEM(tensor_ptr, tensor_iter, data) VSTORE5(tensor_ptr, CURRENT_ITEM_OFFSET(tensor_iter), data)

/** Converting the vec4 object to 4 half-precision (16-bits) floating point values and packing into a uvec2 object
 *
 * @param[in] data The vec4 object to be packed
 *
 * @return The packed uvec2 object
 */
highp uvec2 pack4_half(mediump vec4 data)
{
    return uvec2(packHalf2x16(data.xy), packHalf2x16(data.zw));
}

/** Unpacking the uvec2 object to 4 half-precision (16-bits) floating point values and converting to a vec4 object
 *
 * @param[in] packed_data The uvec2 object to be unpacked
 *
 * @return The unpacked vec4 object
 */
mediump vec4 unpack4_half(highp uvec2 packed_data)
{
    return vec4(unpackHalf2x16(packed_data.x), unpackHalf2x16(packed_data.y));
}

/** Unpacking the uvec3 object to 6 half-precision (16-bits) floating point values and converting to a vec2[3] object
 *
 * @param[in] packed_data The uvec3 object to be unpacked
 *
 * @return The unpacked vec2[3] object
 */
mediump vec2[3] unpack6_half(highp uvec3 packed_data)
{
    return vec2[3](unpackHalf2x16(packed_data[0]),
                   unpackHalf2x16(packed_data[1]),
                   unpackHalf2x16(packed_data[2]));
}

/** Converting the vec4[2] object to 8 half-precision (16-bits) floating point values and packing into a uvec4 object
 *
 * @param[in] data The vec4[2] object to be packed
 *
 * @return The packed uvec4 object
 */
highp uvec4 pack8_half(mediump vec4 data[2])
{
    return uvec4(packHalf2x16(data[0].xy), packHalf2x16(data[0].zw),
                 packHalf2x16(data[1].xy), packHalf2x16(data[1].zw));
}

/** Unpacking the uvec4 object to 8 half-precision (16-bits) floating point values and converting to a vec4[2] object
 *
 * @param[in] packed_data The uvec4 object to be unpacked
 *
 * @return The unpacked vec4[2] object
 */
mediump vec4[2] unpack8_half(highp uvec4 packed_data)
{
    return vec4[2](vec4(unpackHalf2x16(packed_data.x), unpackHalf2x16(packed_data.y)),
                   vec4(unpackHalf2x16(packed_data.z), unpackHalf2x16(packed_data.w)));
}

/** Unpacking the uvec2[3] object to 12 half-precision (16-bits) floating point values and converting to a vec4[3] object
 *
 * @param[in] packed_data The uvec2[3] object to be unpacked
 *
 * @return The unpacked vec4[3] object
 */
mediump vec4[3] unpack12_half(highp uvec2[3] packed_data)
{
    return vec4[3](vec4(unpackHalf2x16(packed_data[0].x), unpackHalf2x16(packed_data[0].y)),
                   vec4(unpackHalf2x16(packed_data[1].x), unpackHalf2x16(packed_data[1].y)),
                   vec4(unpackHalf2x16(packed_data[2].x), unpackHalf2x16(packed_data[2].y)));
}

// For half-precision (16-bits) floating point packed into a "uint" element
#define LOAD_UNPACK2_HALF(tensor_ptr, offset) unpackHalf2x16(uint(LOAD(tensor_ptr, offset)))
#define STORE_PACK2_HALF(tensor_ptr, offset, data) STORE(tensor_ptr, offset, packHalf2x16(data))
#define LOAD_UNPACK2_CURRENT_ITEM_HALF(tensor_ptr, tensor_iter) LOAD_UNPACK2_HALF(tensor_ptr, CURRENT_ITEM_OFFSET(tensor_iter))
#define STORE_PACK2_CURRENT_ITEM_HALF(tensor_ptr, tensor_iter, data) STORE_PACK2_HALF(tensor_ptr, CURRENT_ITEM_OFFSET(tensor_iter), data)

#define VLOAD2_UNPACK4_HALF(tensor_ptr, offset) unpack4_half(VLOAD2(uvec2, tensor_ptr, offset))
#define VSTORE2_PACK4_HALF(tensor_ptr, offset, data) VSTORE2(tensor_ptr, offset, pack4_half(data))
#define VLOAD2_UNPACK4_CURRENT_ITEM_HALF(tensor_ptr, tensor_iter) VLOAD2_UNPACK4_HALF(tensor_ptr, CURRENT_ITEM_OFFSET(tensor_iter))
#define VSTORE2_PACK4_CURRENT_ITEM_HALF(tensor_ptr, tensor_iter, data) VSTORE2_PACK4_HALF(tensor_ptr, CURRENT_ITEM_OFFSET(tensor_iter), data)

#define VLOAD3_UNPACK6_HALF(tensor_ptr, offset) unpack6_half(VLOAD3(uvec3, tensor_ptr, offset))
#define VLOAD3_UNPACK6_CURRENT_ITEM_HALF(tensor_ptr, tensor_iter) VLOAD3_UNPACK6_HALF(tensor_ptr, CURRENT_ITEM_OFFSET(tensor_iter))

#define VLOAD4_UNPACK8_HALF(tensor_ptr, offset) unpack8_half(VLOAD4(uvec4, tensor_ptr, offset))
#define VSTORE4_PACK8_HALF(tensor_ptr, offset, data) VSTORE4(tensor_ptr, offset, pack8_half(data))
#define VLOAD4_UNPACK8_CURRENT_ITEM_HALF(tensor_ptr, tensor_iter) VLOAD4_UNPACK8_HALF(tensor_ptr, CURRENT_ITEM_OFFSET(tensor_iter))
#define VSTORE4_PACK8_CURRENT_ITEM_HALF(tensor_ptr, tensor_iter, data) VSTORE4_PACK8_HALF(tensor_ptr, CURRENT_ITEM_OFFSET(tensor_iter), data)

// For half-precision (16-bits) floating point packed into a "uvec2" element
#define LOAD_UNPACK4_HALF(tensor_ptr, offset) unpack4_half(uvec2(LOAD(tensor_ptr, offset)))
#define STORE_PACK4_HALF(tensor_ptr, offset, data) STORE(tensor_ptr, offset, pack4_half(data))
#define LOAD_UNPACK4_CURRENT_ITEM_HALF(tensor_ptr, tensor_iter) LOAD_UNPACK4_HALF(tensor_ptr, CURRENT_ITEM_OFFSET(tensor_iter))
#define STORE_PACK4_CURRENT_ITEM_HALF(tensor_ptr, tensor_iter, data) STORE_PACK4_HALF(tensor_ptr, CURRENT_ITEM_OFFSET(tensor_iter), data)

#define VLOAD2_UNPACK8_HALF(tensor_ptr, offset) unpack8_half(VLOAD2(uvec4, tensor_ptr, offset))
#define VSTORE2_PACK8_HALF(tensor_ptr, offset, data) VSTORE2(tensor_ptr, offset, pack8_half(data))
#define VLOAD2_UNPACK8_CURRENT_ITEM_HALF(tensor_ptr, tensor_iter) VLOAD2_UNPACK8_HALF(tensor_ptr, CURRENT_ITEM_OFFSET(tensor_iter))
#define VSTORE2_PACK8_CURRENT_ITEM_HALF(tensor_ptr, tensor_iter, data) VSTORE2_PACK8_HALF(tensor_ptr, CURRENT_ITEM_OFFSET(tensor_iter), data)

#define VLOAD3_UNPACK12_HALF(tensor_ptr, offset) unpack12_half(VLOAD3(uvec2[3], tensor_ptr, offset))
#define VLOAD3_UNPACK12_CURRENT_ITEM_HALF(tensor_ptr, tensor_iter) VLOAD3_UNPACK12_HALF(tensor_ptr, CURRENT_ITEM_OFFSET(tensor_iter))

// For half-precision (16-bits) floating point packed into a "uvec4" element
#define LOAD_UNPACK8_HALF(tensor_ptr, offset) unpack8_half(uvec4(LOAD(tensor_ptr, offset)))
#define STORE_PACK8_HALF(tensor_ptr, offset, data) STORE(tensor_ptr, offset, pack8_half(data))
#define LOAD_UNPACK8_CURRENT_ITEM_HALF(tensor_ptr, tensor_iter) LOAD_UNPACK8_HALF(tensor_ptr, CURRENT_ITEM_OFFSET(tensor_iter))
#define STORE_PACK8_CURRENT_ITEM_HALF(tensor_ptr, tensor_iter, data) STORE_PACK8_HALF(tensor_ptr, CURRENT_ITEM_OFFSET(tensor_iter), data)

/** Converting the uvec4 object to 4 low-precision uint values and packing into a uint object
 *
 * @param[in] data The uvec4 object to be packed
 *
 * @return The packed uint object
 */
highp uint pack4_u8(lowp uvec4 data)
{
    highp uint r = uint(0);

    for(int i = 0; i < 4; i++)
    {
        r |= data[i] << uint(i * 8);
    }

    return r;
}

/** Unpacking the uint object to 4 low-precision uint values and converting to a uvec4 object
 *
 * @param[in] packed_data The uint object to be unpacked
 *
 * @return The unpacked uvec4 object
 */
lowp uvec4 unpack4_u8(highp uint packed_data)
{
    lowp uvec4 uvec;

    for(int i = 0; i < 4; i++)
    {
        uvec[i] = (packed_data >> uint(i * 8)) & uint(0xFF);
    }

    return uvec;
}

#define LOAD_UNPACK4_U8(tensor_ptr, offset) unpack4_u8(uint(LOAD(tensor_ptr, offset)))
#define STORE_PACK4_U8(tensor_ptr, offset, data) STORE(tensor_ptr, offset, pack4_u8(data))
#define LOAD_UNPACK4_CURRENT_ITEM_U8(tensor_ptr, tensor_iter) LOAD_UNPACK4_U8(tensor_ptr, CURRENT_ITEM_OFFSET(tensor_iter))
#define STORE_PACK4_CURRENT_ITEM_U8(tensor_ptr, tensor_iter, data) STORE_PACK4_U8(tensor_ptr, CURRENT_ITEM_OFFSET(tensor_iter), data)

#endif // ARM_COMPUTE_HELPER_CS_H

#if defined(DATA_TYPE_FP16)
precision mediump float;
#endif // DATA_TYPE_FP16

#ifdef RESHAPE_TO_COLUMNS

/** This kernel performs a reshaping of the input tensor to a tensor used to perform convolution using GEMM.
 *
 * @note The data type must be passed at compile time using "#define DATA_TYPE_NAME". e.g. "#define DATA_TYPE_FP32"
 * @note In case biases will be added to the convolution "#define HAS_BIAS" has to be passed to append the final matrix with 1 in each row.
 *
 * @param[in]  src_ptr       Pointer to the source tensor. Supported data types: F16/F32
 * @param[in]  src_attrs     The attributes of the source tensor
 * @param[out] dst_ptr       Pointer to the destination tensor. Supported data types: same as @p src_ptr
 * @param[in]  dst_attrs     The attributes of the destination tensor
 * @param[in]  biases_ptr    Pointer to the biases tensor. Same as @p src_ptr
 * @param[in]  biases_attrs  The attributes of the biases tensor
 * @param[in]  width         The width of the input tensor
 * @param[in]  height        The height of the input tensor
 * @param[in]  depth         The depth of the input tensor
 * @param[in]  total_filters Total number of filters. 4th dimension of the weights matrix
 */

SHADER_PARAMS_DECLARATION
{
    Tensor3DAttributes src_attrs;
    ImageAttributes    dst_attrs;
#ifdef HAS_BIAS
    VectorAttributes biases_attrs;
#endif /* HAS_BIAS */
    uint width;
    uint height;
    uint depth;
    uint total_filters;
};

#if defined(DATA_TYPE_FP32)

TENSOR_DECLARATION(1, srcBuffer, float, src_ptr, src_shift, 2, readonly);
TENSOR_DECLARATION(2, dstBuffer, float, dst_ptr, dst_shift, 2, writeonly);
#ifdef HAS_BIAS
TENSOR_DECLARATION(3, biasesBuffer, float, biases_ptr, biases_shift, 2, readonly);
#endif /* BIAS */

void main()
{
    Tensor3DIterator src_iter = CONVERT_TO_TENSOR3D_ITERATOR(src_attrs, src_shift);
    ImageIterator    dst_iter = CONVERT_TO_IMAGE_ITERATOR_NO_STEP(dst_attrs, dst_shift);
#ifdef HAS_BIAS
    VectorIterator biases_iter = CONVERT_TO_VECTOR_ITERATOR_NO_STEP(biases_attrs, biases_shift);
#endif /* BIAS */

    bool is_last_thread = (((int(gl_GlobalInvocationID.x)) == (int(gl_NumWorkGroups.x * gl_WorkGroupSize.x) - 1)) && ((int(gl_GlobalInvocationID.y)) == (int(gl_NumWorkGroups.y * gl_WorkGroupSize.y) - 1))
                           && ((int(gl_GlobalInvocationID.z)) == (int(gl_NumWorkGroups.z * gl_WorkGroupSize.z) - 1)));
    TENSOR_ITERATOR_ADVANCE_IN_BYTES(dst_iter, ((uint(gl_GlobalInvocationID.x) * uint(dst_attrs.stride_y)) + (uint(gl_GlobalInvocationID.y) * uint(width) * uint(dst_attrs.stride_y)) + (uint(
                                                    gl_GlobalInvocationID.z)
                                                * uint(width) * uint(height) * uint(dst_attrs.stride_y))));
    // Linearize convolution elements
    if(is_last_thread)
    {
        for(uint i = 0u; i < uint(total_filters); ++i)
        {
            float s0 = LOAD_CURRENT_ITEM(src_ptr, src_iter);
            STORE_CURRENT_ITEM(dst_ptr, dst_iter, s0);
            TENSOR_ITERATOR_ADVANCE_IN_BYTES(src_iter, (depth * src_attrs.stride_z));
#ifdef HAS_BIAS
            float b = LOAD_CURRENT_ITEM(biases_ptr, biases_iter);
            STORE(dst_ptr, TENSOR_OFFSET_ADVANCE_IN_BYTES(dst_iter, dst_attrs.stride_y), b);
            TENSOR_ITERATOR_ADVANCE_IN_BYTES(biases_iter, biases_attrs.stride_x);
#endif /* HAS_BIAS */
            TENSOR_ITERATOR_ADVANCE_IN_BYTES(dst_iter, dst_attrs.stride_x);
        }
    }
    else
    {
        for(uint i = 0u; i < uint(total_filters); ++i)
        {
            float s0 = LOAD_CURRENT_ITEM(src_ptr, src_iter);
            STORE_CURRENT_ITEM(dst_ptr, dst_iter, s0);
            TENSOR_ITERATOR_ADVANCE_IN_BYTES(src_iter, (depth * src_attrs.stride_z));
            TENSOR_ITERATOR_ADVANCE_IN_BYTES(dst_iter, dst_attrs.stride_x);
        }
    }
}

#elif defined(DATA_TYPE_FP16)

TENSOR_DECLARATION(1, srcBuffer, uint, src_ptr, src_shift, 2, readonly);
TENSOR_DECLARATION(2, dstBuffer, uint, dst_ptr, dst_shift, 2, writeonly);
#ifdef HAS_BIAS
TENSOR_DECLARATION(3, biasesBuffer, uint, biases_ptr, biases_shift, 2, readonly);
#endif /* BIAS */

void main()
{
    Tensor3DIterator src_iter    = CONVERT_TO_TENSOR3D_ITERATOR(src_attrs, src_shift);
    ImageIterator    dst_iter    = CONVERT_TO_IMAGE_ITERATOR_NO_STEP(dst_attrs, dst_shift);
#ifdef HAS_BIAS
    VectorIterator   biases_iter = CONVERT_TO_VECTOR_ITERATOR_NO_STEP(biases_attrs, biases_shift);
#endif /* BIAS */

    bool is_last_thread = (((int(gl_GlobalInvocationID.x)) == (int(gl_NumWorkGroups.x * gl_WorkGroupSize.x) - 1)) && ((int(gl_GlobalInvocationID.y)) == (int(gl_NumWorkGroups.y * gl_WorkGroupSize.y) - 1))
                           && ((int(gl_GlobalInvocationID.z)) == (int(gl_NumWorkGroups.z * gl_WorkGroupSize.z) - 1)));
    TENSOR_ITERATOR_ADVANCE_IN_BYTES(dst_iter, ((uint(gl_GlobalInvocationID.x) * uint(dst_attrs.stride_y)) + (uint(gl_GlobalInvocationID.y) * uint(width) * uint(dst_attrs.stride_y)) + (uint(
                                                    gl_GlobalInvocationID.z)
                                                * uint(width) * uint(height) * uint(dst_attrs.stride_y))));
    // Linearize convolution elements
    if(is_last_thread)
    {
        for(uint i = 0u; i < uint(total_filters); i = i + 2u)
        {
            vec2 s0 = LOAD_UNPACK2_CURRENT_ITEM_HALF(src_ptr, src_iter);
            vec2 s;
            if(int(CURRENT_ITEM_OFFSET_IN_BYTES(src_iter) >> 1u) % 2 == 0)
            {
                s.x = s0.x;
            }
            else
            {
                s.x = s0.y;
            }
            TENSOR_ITERATOR_ADVANCE_IN_BYTES(src_iter, (depth * src_attrs.stride_z));

            vec2 s1 = LOAD_UNPACK2_CURRENT_ITEM_HALF(src_ptr, src_iter);
            if(int(CURRENT_ITEM_OFFSET_IN_BYTES(src_iter) >> 1u) % 2 == 0)
            {
                s.y = s1.x;
            }
            else
            {
                s.y = s1.y;
            }
            STORE_PACK2_CURRENT_ITEM_HALF(dst_ptr, dst_iter, s);
            TENSOR_ITERATOR_ADVANCE_IN_BYTES(src_iter, (depth * src_attrs.stride_z));
#ifdef HAS_BIAS
            vec2 b = LOAD_UNPACK2_CURRENT_ITEM_HALF(biases_ptr, biases_iter);
            STORE_PACK2_HALF(dst_ptr, TENSOR_OFFSET_ADVANCE_IN_BYTES(dst_iter, dst_attrs.stride_y), b);
            TENSOR_ITERATOR_ADVANCE_IN_BYTES(biases_iter, (2u * biases_attrs.stride_x));
#endif /* HAS_BIAS */
            TENSOR_ITERATOR_ADVANCE_IN_BYTES(dst_iter, (2u * dst_attrs.stride_x));
        }
    }
    else
    {
        for(uint i = 0u; i < uint(total_filters); i = i + 2u)
        {
            vec2 s0 = LOAD_UNPACK2_CURRENT_ITEM_HALF(src_ptr, src_iter);
            vec2 s;
            if(int(CURRENT_ITEM_OFFSET_IN_BYTES(src_iter) >> 1u) % 2 == 0)
            {
                s.x = s0.x;
            }
            else
            {
                s.x = s0.y;
            }
            TENSOR_ITERATOR_ADVANCE_IN_BYTES(src_iter, (depth * src_attrs.stride_z));

            vec2 s1 = LOAD_UNPACK2_CURRENT_ITEM_HALF(src_ptr, src_iter);
            if(int(CURRENT_ITEM_OFFSET_IN_BYTES(src_iter) >> 1u) % 2 == 0)
            {
                s.y = s1.x;
            }
            else
            {
                s.y = s1.y;
            }
            STORE_PACK2_CURRENT_ITEM_HALF(dst_ptr, dst_iter, s);
            TENSOR_ITERATOR_ADVANCE_IN_BYTES(src_iter, (depth * src_attrs.stride_z));
            TENSOR_ITERATOR_ADVANCE_IN_BYTES(dst_iter, (2u * dst_attrs.stride_x));
        }
    }
}

#endif /* DATA_TYPE_FP32 */
#endif // RESHAPE_TO_COLUMNS

#ifdef IM2COL_GENERIC

/** This kernel performs a reshaping of the input tensor to a tensor used to perform convolution using GEMM.
 *
 * @note The data type must be passed at compile time using "#define DATA_TYPE_FP32"
 * @note PAD_LEFT/PAD_RIGHT/PAD_TOP/PAD_BOTTOM must be passed for padding info, e.g. "#define PAD_LEFT xxx"
 * @note KERNEL_WIDTH/KERNEL_HEIGHT/KERNEL_DEPTH must be passed for kernel dimension, e.g. "#define KERNEL_WIDTH xxx"
 * @note STRIDE_X/STRIDE_Y must be passed for stride info, e.g. "#define STRIDE_X xxx"
 * @note CONVOLVED_WIDTH/CONVOLVED_HEIGHT must be passed for convolved dimension, e.g. "#define CONVOLVED_WIDTH xxx"
 * @note SRC_WIDTH/SRC_HEIGHT must be passed for input dimension, e.g. "#define SRC_WIDTH xxx"
 * @note DILATION_X/DILATION_Y must be passed for dilation sizes, e.g. "#define DILATION_X xxx"
 * @note In case biases will be added to the convolution "#define HAS_BIAS" has to be passed to append the final matrix with 1 in each row.
 *
 * @param[in]  src_ptr      Pointer to the source tensor. Supported data types: F16/F32
 * @param[in]  src_attrs    The attributes of the source tensor
 * @param[out] dst_ptr      Pointer to the destination tensor. Supported data types: same as @p src_ptr
 * @param[in]  dst_attrs    The attributes of the destination tensor
 * @param[in]  src_stride_w Stride of the source tensor in W dimension (in bytes).
 * @param[in]  dst_stride_w Stride of the destination tensor in W dimension (in bytes).
 */

SHADER_PARAMS_DECLARATION
{
    Tensor3DAttributes src_attrs;
    ImageAttributes    dst_attrs;
    uint               src_stride_w;
    uint               dst_stride_w;
};

#ifdef DATA_TYPE_FP32

TENSOR_DECLARATION(1, srcBuffer, float, src_ptr, src_shift, 2, readonly);
TENSOR_DECLARATION(2, dstBuffer, float, dst_ptr, dst_shift, 2, restrict);

void main(void)
{
    Tensor3DIterator src_iter = CONVERT_TO_TENSOR3D_ITERATOR_NO_STEP(src_attrs, src_shift);
    ImageIterator    dst_iter = CONVERT_TO_IMAGE_ITERATOR_NO_STEP(dst_attrs, dst_shift);

    int xc    = int(gl_GlobalInvocationID.x);                // x coordinate in the convolved tensor
    int yc    = int(gl_GlobalInvocationID.y);                // y coordinate in the convolved tensor
    int ch    = int(gl_GlobalInvocationID.z) % KERNEL_DEPTH; // input feature map
    int batch = int(gl_GlobalInvocationID.z) / KERNEL_DEPTH; // the batch

    // Calculate input indeces
    int xi = xc * STRIDE_X - PAD_LEFT;
    int yi = yc * STRIDE_Y - PAD_TOP;
    TENSOR_ITERATOR_ADVANCE_IN_BYTES(src_iter, (ch * int(src_attrs.stride_z)) + (batch * int(src_stride_w)));

    // Calculate output indeces
    int xo = ch * KERNEL_WIDTH * KERNEL_HEIGHT;
    int yo = xc + yc * CONVOLVED_WIDTH; // Index of the convolution
    // sizeof is not available in GLES, so we'll use stride_x
    TENSOR_ITERATOR_ADVANCE_IN_BYTES(dst_iter, (yo * int(dst_attrs.stride_y)) + (batch * int(dst_stride_w)) + xo * int(dst_attrs.stride_x));

    uint src_pos = 0u;

    // Linearize convolution elements
    for(int y = yi, y_e = yi + KERNEL_HEIGHT * DILATION_Y; y < y_e; y += DILATION_Y)
    {
        for(int x = xi, x_e = xi + KERNEL_WIDTH * DILATION_X; x < x_e; x += DILATION_X, TENSOR_ITERATOR_ADVANCE_IN_BYTES(dst_iter, int(dst_attrs.stride_x)))
        {
#if PAD_LEFT == 0 && PAD_TOP == 0 && PAD_RIGHT == 0 && PAD_BOTTOM == 0
            src_pos = TENSOR_OFFSET_ADVANCE_IN_BYTES(src_iter, x * int(src_attrs.stride_x) + y * int(src_attrs.stride_y));
            STORE_CURRENT_ITEM(dst_ptr, dst_iter, LOAD(src_ptr, src_pos));
#else  /* PAD_LEFT == 0 && PAD_TOP == 0 && PAD_RIGHT == 0 && PAD_BOTTOM == 0 */
            if(x < 0 || x >= SRC_WIDTH || y < 0 || y >= SRC_HEIGHT)
            {
                STORE_CURRENT_ITEM(dst_ptr, dst_iter, 0.0f);
            }
            else
            {
                src_pos = TENSOR_OFFSET_ADVANCE_IN_BYTES(src_iter, x * int(src_attrs.stride_x) + y * int(src_attrs.stride_y));
                STORE_CURRENT_ITEM(dst_ptr, dst_iter, LOAD(src_ptr, src_pos));
            }
#endif /* PAD_LEFT == 0 && PAD_TOP == 0 && PAD_RIGHT == 0 && PAD_BOTTOM == 0 */
        }
    }

#ifdef HAS_BIAS
    if(ch == (KERNEL_DEPTH - 1))
    {
        STORE_CURRENT_ITEM(dst_ptr, dst_iter, 1.0f);
    }
#endif /* HAS_BIAS */
}

#elif defined(DATA_TYPE_FP16)

TENSOR_DECLARATION(1, srcBuffer, uint, src_ptr, src_shift, 2, readonly);
TENSOR_DECLARATION(2, dstBuffer, uint, dst_ptr, dst_shift, 2, writeonly);

#ifdef KERNEL_1x1

void main(void)
{
    Tensor3DIterator src_iter = CONVERT_TO_TENSOR3D_ITERATOR_NO_STEP(src_attrs, src_shift);
    ImageIterator    dst_iter = CONVERT_TO_IMAGE_ITERATOR_NO_STEP(dst_attrs, dst_shift);

    uint xc    = gl_GlobalInvocationID.x;
    uint yc    = gl_GlobalInvocationID.y;
    uint zc    = gl_GlobalInvocationID.z;
    uint ch    = zc % uint(KERNEL_DEPTH); // input feature map
    uint batch = zc / uint(KERNEL_DEPTH); // the batch

    // Calculate input indeces
    uint xi = xc;
    uint yi = yc;
    TENSOR_ITERATOR_ADVANCE_IN_BYTES(src_iter, batch * src_stride_w + ch * src_attrs.step_z);

    // Calculate output indeces
    uint dst_element_count = dst_attrs.step_x / dst_attrs.stride_x;
    uint xo                = ch * dst_element_count;
    uint yo                = xc + yc * uint(CONVOLVED_WIDTH);
    TENSOR_ITERATOR_ADVANCE_IN_BYTES(dst_iter, batch * dst_stride_w + yo * dst_attrs.stride_y + xo);

    bool x_start_even = ((xc % 2u) == 0u);
    bool z_depth_even = ((uint(KERNEL_DEPTH) % 2u) == 0u);
    uint input_pos    = TENSOR_OFFSET_ADVANCE_IN_BYTES(src_iter, xi * src_attrs.stride_x + yi * src_attrs.stride_y);
    uint tmp_left     = 0u;
    uint tmp_right    = 0u;

    if(ch % 2u != 0u)
    {
        return;
    }

    if(z_depth_even || (!z_depth_even && (int(ch) < (KERNEL_DEPTH - 1))))
    {
        tmp_left  = LOAD(src_ptr, input_pos);
        input_pos = TENSOR_OFFSET_ADVANCE_IN_BYTES(src_iter, xi * src_attrs.stride_x + yi * src_attrs.stride_y + src_attrs.stride_z);
        tmp_right = LOAD(src_ptr, input_pos);
        if(x_start_even)
        {
            tmp_right = (tmp_left & 0xffffu) + (tmp_right << 16u);
        }
        else
        {
            tmp_right = (tmp_left >> 16u) + (tmp_right & 0xffff0000u);
        }
        STORE_CURRENT_ITEM(dst_ptr, dst_iter, tmp_right);
        TENSOR_ITERATOR_ADVANCE_IN_BYTES(dst_iter, dst_attrs.step_x);

#ifdef HAS_BIAS
        if(ch == (uint(KERNEL_DEPTH) - 2u))
        {
            mediump vec2 bias_vec = vec2(1.f, 0.f);
            uint         bias_u   = packHalf2x16(bias_vec);
            STORE_CURRENT_ITEM(dst_ptr, dst_iter, bias_u);
        }
#endif /* HAS_BIAS */
    }
    else
    {
        tmp_left = LOAD(src_ptr, input_pos);
        if(x_start_even)
        {
            tmp_right = (tmp_left & 0xffffu);
        }
        else
        {
            tmp_right = (tmp_left >> 16u);
        }

#ifdef HAS_BIAS
        mediump vec2 bias_vec = vec2(0.f, 1.f);
        uint         bias_u   = packHalf2x16(bias_vec);
        tmp_right += (bias_u & 0xffff0000u);
#endif /* HAS_BIAS */

        STORE_CURRENT_ITEM(dst_ptr, dst_iter, tmp_right);
    }
}

#else /* KERNEL_1x1 */

void main(void)
{
    uint xc    = gl_GlobalInvocationID.x;
    uint yc    = gl_GlobalInvocationID.y;
    uint zc    = gl_GlobalInvocationID.z;
    uint ch    = zc % uint(KERNEL_DEPTH); // input feature map
    uint batch = zc / uint(KERNEL_DEPTH); // the batch

    Tensor3DIterator src_iter   = CONVERT_TO_TENSOR3D_ITERATOR_NO_STEP(src_attrs, src_shift);
    Tensor3DIterator src_iter_b = CONVERT_TO_TENSOR3D_ITERATOR_NO_STEP(src_attrs, src_shift);
    ImageIterator    dst_iter   = CONVERT_TO_IMAGE_ITERATOR_NO_STEP(dst_attrs, dst_shift);

    // Calculate input indeces
    uint src_element_count = src_attrs.step_x / src_attrs.stride_x;
    uint xi                = (xc * uint(STRIDE_X)) / src_element_count;
    uint yi                = yc * uint(STRIDE_Y);
    TENSOR_ITERATOR_ADVANCE_IN_BYTES(src_iter, batch * src_stride_w + ch * src_attrs.stride_z);

    // Calculate output indeces
    uint dst_element_count = dst_attrs.step_x / dst_attrs.stride_x;
    uint xo                = (ch * uint(KERNEL_WIDTH) * uint(KERNEL_HEIGHT)) * dst_element_count;
    uint yo                = xc + yc * uint(CONVOLVED_WIDTH);
    TENSOR_ITERATOR_ADVANCE_IN_BYTES(dst_iter, batch * dst_stride_w + yo * dst_attrs.stride_y + xo);

    bool x_start_even = ((xc * uint(STRIDE_X)) % 2u == 0u);
    bool z_start_even = ((ch % 2u) == 0u);
    uint input_pos    = 0u;
    uint tmp          = 0u;
    uint tmp_left     = 0u;
    uint tmp_right    = 0u;

    // Linearize convolution elements
    for(uint y = yi, y_e = yi + uint(KERNEL_HEIGHT); y < y_e; ++y)
    {
        uint xstart = 0u;
        uint xend   = 0u;

        // even col, even row
        if(x_start_even)
        {
            if(((y - yi + ch) % 2u) == 0u)
            {
                for(uint x = xi, x_e = xi + (uint(KERNEL_WIDTH) / 2u); x < x_e; ++x, TENSOR_ITERATOR_ADVANCE_IN_BYTES(dst_iter, dst_attrs.step_x))
                {
                    input_pos = TENSOR_OFFSET_ADVANCE_IN_BYTES(src_iter, x * src_attrs.step_x + y * src_attrs.stride_y);
                    STORE_CURRENT_ITEM(dst_ptr, dst_iter, LOAD(src_ptr, input_pos));
                }
            }
            else
            {
                // 1st pair
                if(!z_start_even && (y == yi))
                {
                    // cross 2d feature map
                    input_pos = TENSOR_OFFSET_ADVANCE_IN_BYTES(src_iter_b, (xi + (uint(KERNEL_WIDTH) / 2u)) * src_attrs.step_x + (yi + uint(KERNEL_HEIGHT) - 1u) * src_attrs.stride_y + batch * src_stride_w +
                                                               (ch - 1u) * src_attrs.stride_z);
                }
                else
                {
                    input_pos = TENSOR_OFFSET_ADVANCE_IN_BYTES(src_iter,
                                                               (xi + (uint(KERNEL_WIDTH) / 2u)) * src_attrs.step_x + (y - 1u) * src_attrs.stride_y);
                }
                tmp_right = LOAD(src_ptr, input_pos);
                input_pos = TENSOR_OFFSET_ADVANCE_IN_BYTES(src_iter, xi * src_attrs.step_x + y * src_attrs.stride_y);
                tmp_left  = LOAD(src_ptr, input_pos);
                tmp_right = (tmp_right & 0xffffu) + (tmp_left << 16u);
                STORE_CURRENT_ITEM(dst_ptr, dst_iter, tmp_right);
                TENSOR_ITERATOR_ADVANCE_IN_BYTES(dst_iter, dst_attrs.step_x);

                // remaining
                for(uint x = xi + 1u, x_e = xi + (uint(KERNEL_WIDTH) / 2u) + 1u; x < x_e; ++x, TENSOR_ITERATOR_ADVANCE_IN_BYTES(dst_iter, dst_attrs.step_x))
                {
                    input_pos = TENSOR_OFFSET_ADVANCE_IN_BYTES(src_iter, (x - 1u) * src_attrs.step_x + y * src_attrs.stride_y);
                    tmp_left  = LOAD(src_ptr, input_pos);
                    input_pos = TENSOR_OFFSET_ADVANCE_IN_BYTES(src_iter, x * src_attrs.step_x + y * src_attrs.stride_y);
                    tmp_right = LOAD(src_ptr, input_pos);
                    tmp_right = (tmp_left >> 16u) + (tmp_right << 16u);
                    STORE_CURRENT_ITEM(dst_ptr, dst_iter, tmp_right);
                }
            }
        }
        else
        {
            if((((y - yi) % 2u) == 0u && !z_start_even) || (((y - yi) % 2u) != 0u && z_start_even))
            {
                // 1st pair
                if(y == yi)
                {
                    // cross 2d feature map
                    input_pos = TENSOR_OFFSET_ADVANCE_IN_BYTES(src_iter_b, (xi + (uint(KERNEL_WIDTH) / 2u)) * src_attrs.step_x + (yi + uint(KERNEL_HEIGHT) - 1u) * src_attrs.stride_y + batch * src_stride_w +
                                                               (ch - 1u) * src_attrs.stride_z);
                }
                else
                {
                    input_pos = TENSOR_OFFSET_ADVANCE_IN_BYTES(src_iter,
                                                               (xi + (uint(KERNEL_WIDTH) / 2u)) * src_attrs.step_x + (y - 1u) * src_attrs.stride_y);
                }

                tmp_right = LOAD(src_ptr, input_pos);
                input_pos = TENSOR_OFFSET_ADVANCE_IN_BYTES(src_iter, xi * src_attrs.step_x + y * src_attrs.stride_y);
                tmp_left  = LOAD(src_ptr, input_pos);
                tmp_right = (tmp_right >> 16u) + (tmp_left & 0xffff0000u);
                STORE_CURRENT_ITEM(dst_ptr, dst_iter, tmp_right);
                TENSOR_ITERATOR_ADVANCE_IN_BYTES(dst_iter, dst_attrs.step_x);

                // remaining
                for(uint x = xi + 1u, x_e = xi + (uint(KERNEL_WIDTH) / 2u) + 1u; x < x_e; ++x, TENSOR_ITERATOR_ADVANCE_IN_BYTES(dst_iter, dst_attrs.step_x))
                {
                    input_pos = TENSOR_OFFSET_ADVANCE_IN_BYTES(src_iter, x * src_attrs.step_x + y * src_attrs.stride_y);
                    STORE_CURRENT_ITEM(dst_ptr, dst_iter, LOAD(src_ptr, input_pos));
                }
            }
            else if((((y - yi) % 2u) == 0u && z_start_even) || (((y - yi) % 2u) != 0u && !z_start_even))
            {
                // 1st pair
                input_pos = TENSOR_OFFSET_ADVANCE_IN_BYTES(src_iter, xi * src_attrs.step_x + y * src_attrs.stride_y);
                tmp_right = LOAD(src_ptr, input_pos);
                input_pos = TENSOR_OFFSET_ADVANCE_IN_BYTES(src_iter, (xi + 1u) * src_attrs.step_x + y * src_attrs.stride_y);
                tmp_left  = LOAD(src_ptr, input_pos);
                tmp_right = (tmp_right >> 16u) + (tmp_left << 16u);
                STORE_CURRENT_ITEM(dst_ptr, dst_iter, tmp_right);
                TENSOR_ITERATOR_ADVANCE_IN_BYTES(dst_iter, dst_attrs.step_x);

                // remaining
                for(uint x = xi + 1u, x_e = xi + (uint(KERNEL_WIDTH) / 2u); x < x_e; ++x, TENSOR_ITERATOR_ADVANCE_IN_BYTES(dst_iter, dst_attrs.step_x))
                {
                    input_pos = TENSOR_OFFSET_ADVANCE_IN_BYTES(src_iter, x * src_attrs.step_x + y * src_attrs.stride_y);
                    tmp_right = LOAD(src_ptr, input_pos);
                    input_pos = TENSOR_OFFSET_ADVANCE_IN_BYTES(src_iter, (x + 1u) * src_attrs.step_x + y * src_attrs.stride_y);
                    tmp_left  = LOAD(src_ptr, input_pos);
                    tmp_right = (tmp_right >> 16u) + (tmp_left << 16u);
                    STORE_CURRENT_ITEM(dst_ptr, dst_iter, tmp_right);
                }
            }
        }
    }

    // NOTE: must handle last element manually instead of in loops
    // to avoid write conflict across 2d boundary
    if(ch == uint(KERNEL_DEPTH) - 1u)
    {
        uint x    = xi + (uint(KERNEL_WIDTH) / 2u);
        uint y    = yi + uint(KERNEL_HEIGHT) - 1u;
        input_pos = TENSOR_OFFSET_ADVANCE_IN_BYTES(src_iter, x * src_attrs.step_x + y * src_attrs.stride_y);
        tmp       = LOAD(src_ptr, input_pos);
        if(!x_start_even)
        {
            tmp = (tmp >> 16u) + (tmp << 16u);
        }

#ifdef HAS_BIAS
        mediump vec2 bias_vec = vec2(1.f, 1.f);
        uint         bias_u   = packHalf2x16(bias_vec);
        if(z_start_even)
        {
            tmp = (tmp & 0xffffu) + (bias_u & 0xffff0000u);
        }
        else
        {
            tmp = (bias_u & 0xffffu);
        }
#endif /* HAS_BIAS */

        STORE_CURRENT_ITEM(dst_ptr, dst_iter, tmp);
    }
}

#endif /* KERNEL_1x1 */
#else  /* DATA_TYPE_FP32 */
#error Data type not supported
#endif /* DATA_TYPE_FP32 */
#endif /* IM2COL_GENERIC */

#ifdef IM2COL_REDUCED

/** This kernel reshapes the tensor's low three dimensions to single row for GEMM operation
 *
 * @note The data type must be passed at compile time using "#define DATA_TYPE_FP16"
 * @note In case biases will be added in late stage, "#define HAS_BIAS" has to be passed to append the final matrix with 1 in each row.
 *
 * @param[in]  src_ptr   Pointer to the source tensor. Supported data types: F16/F32
 * @param[in]  src_attrs The attributes of the source tensor
 * @param[out] dst_ptr   Pointer to the destination tensor. Same as @p src_ptr
 * @param[in]  dst_attrs The attributes of the destination tensor
 * @param[in]  width     The width of the input tensor
 * @param[in]  height    The height of the input tensor
 */

SHADER_PARAMS_DECLARATION
{
    Tensor3DAttributes src_attrs;
    VectorAttributes   dst_attrs;
    uint               width;
    uint               height;
};

#ifdef DATA_TYPE_FP32

TENSOR_DECLARATION(1, srcBuffer, float, src_ptr, src_shift, 2, readonly);
TENSOR_DECLARATION(2, dstBuffer, float, dst_ptr, dst_shift, 2, restrict);

void main(void)
{
    Tensor3DIterator src_iter = CONVERT_TO_TENSOR3D_ITERATOR(src_attrs, src_shift);
    VectorIterator   dst_iter = CONVERT_TO_VECTOR_ITERATOR_NO_STEP(dst_attrs, dst_shift);

    uvec3 pos            = uvec3(gl_GlobalInvocationID.xyz);
    uvec3 size           = uvec3(gl_WorkGroupSize.xyz);
    uint  image_size     = width * height;
    uint  tmp_out_offset = VECTOR_OFFSET(dst_iter, pos.x + pos.y * width + pos.z * image_size);

    STORE(dst_ptr, tmp_out_offset, LOAD_CURRENT_ITEM(src_ptr, src_iter));

#ifdef HAS_BIAS
    // If it is the last thread in the 3 dimensional workgroup
    if(pos.x == (size.x - 1) && pos.y == (size.y - 1) && pos.z == (size.z - 1))
    {
        tmp_out_offset += (dst_attrs.stride_x >> uint(2));
        STORE(dst_ptr, tmp_out_offset, 1.f);
    }
#endif // HAS_BIAS
}

#elif defined(DATA_TYPE_FP16)

#if defined(IM2COL_REDUCED_8X)
TENSOR_DECLARATION(1, srcBuffer, uvec4, src_ptr, src_shift, 4, readonly);
TENSOR_DECLARATION(2, dstBuffer, uvec4, dst_ptr, dst_shift, 4, restrict);
#elif defined(IM2COL_REDUCED_4X) /* IM2COL_REDUCED_8X */
TENSOR_DECLARATION(1, srcBuffer, uvec2, src_ptr, src_shift, 3, readonly);
TENSOR_DECLARATION(2, dstBuffer, uvec2, dst_ptr, dst_shift, 3, restrict);
#else                            /* IM2COL_REDUCED_8X */
TENSOR_DECLARATION(1, srcBuffer, uint, src_ptr, src_shift, 2, readonly);
TENSOR_DECLARATION(2, dstBuffer, uint, dst_ptr, dst_shift, 2, restrict);
#endif                           /* IM2COL_REDUCED_8X */

#if defined(IM2COL_REDUCED_GENERIC)

void main(void)
{
    Tensor3DIterator src_iter        = CONVERT_TO_TENSOR3D_ITERATOR(src_attrs, src_shift);
    Tensor3DIterator src_nostep_iter = CONVERT_TO_TENSOR3D_ITERATOR_NO_STEP(src_attrs, src_shift);
    VectorIterator   dst_iter        = CONVERT_TO_VECTOR_ITERATOR_NO_STEP(dst_attrs, dst_shift);

    uvec3 pos            = uvec3(gl_GlobalInvocationID.xyz);
    uvec3 size           = uvec3(gl_WorkGroupSize.xyz);
    uint  image_size     = width * height;
    uint  element_count  = src_attrs.step_x / src_attrs.stride_x;
    uint  tmp_out_offset = VECTOR_OFFSET(dst_iter, pos.x * element_count + pos.y * width + pos.z * image_size);
    uint  width_fp16     = (width + uint(1)) >> uint(1);
    uint  tmp;

    // odd width
    if(width % uint(2) != uint(0))
    {
        // even row
        if((pos.y + pos.z * height) % uint(2) == uint(0))
        {
            // skip last element of each line to avoid write conflict except for last line
            if((pos.x < (width / element_count)) || ((pos.y == gl_NumWorkGroups.y - 1u) && (pos.z == gl_NumWorkGroups.z - 1u)))
            {
                tmp = LOAD_CURRENT_ITEM(src_ptr, src_iter);
                STORE(dst_ptr, tmp_out_offset, tmp);
            }
        }
        else
        {
            // special op
            uint tmp_left  = uint(0);
            uint tmp_right = uint(0);
            tmp_right      = LOAD_CURRENT_ITEM(src_ptr, src_iter); //right half
            if(pos.x == uint(0))
            {
                tmp_left  = LOAD(src_ptr, TENSOR3D_OFFSET(src_nostep_iter, int(width), int(pos.y) - 1, int(pos.z))); //left half
                tmp_right = (tmp_left & uint(0xffff)) + (tmp_right << uint(16));
            }
            else
            {
                tmp_left  = LOAD(src_ptr, TENSOR3D_OFFSET(src_nostep_iter, (int(pos.x) - 1) * int(element_count), int(pos.y), int(pos.z)));
                tmp_right = ((tmp_left >> uint(16)) + (tmp_right << uint(16)));
            }
            STORE(dst_ptr, tmp_out_offset, tmp_right);
        }
    }
    else
    {
        tmp = LOAD_CURRENT_ITEM(src_ptr, src_iter);
        STORE(dst_ptr, tmp_out_offset, tmp);
    }

#ifdef HAS_BIAS
    // If it is the last thread in the 3 dimensional workgroup
    if(pos.x == (size.x - 1u) && pos.y == (size.y - 1u) && pos.z == (size.z - 1u))
    {
        tmp_out_offset += (dst_attrs.stride_x >> dst_shift);

        // FIXME: need odd/even detection for tmp_out_offset?
        mediump vec2 bias_vec = vec2(1.0f, 1.0f);
        STORE_PACK2_HALF(dst_ptr, tmp_out_offset, bias_vec);
    }
#endif // HAS_BIAS
}

#else /* IM2COL_REDUCED_GENERIC */

void main(void)
{
    Tensor3DIterator src_iter = CONVERT_TO_TENSOR3D_ITERATOR(src_attrs, src_shift);
    VectorIterator   dst_iter = CONVERT_TO_VECTOR_ITERATOR_NO_STEP(dst_attrs, dst_shift);

    uvec3 pos            = uvec3(gl_GlobalInvocationID.xyz);
#if defined(IM2COL_REDUCED_8X)
    uint  tmp_out_offset = VECTOR_OFFSET(dst_iter, pos.x * uint(8) + pos.y * width + pos.z * uint(IMAGE_SIZE));
    uvec4 tmp            = LOAD_CURRENT_ITEM(src_ptr, src_iter);
    STORE(dst_ptr, tmp_out_offset, tmp);
#elif defined(IM2COL_REDUCED_4X) /* IM2COL_REDUCED_8X */
    uint  tmp_out_offset = VECTOR_OFFSET(dst_iter, pos.x * uint(4) + pos.y * width + pos.z * uint(IMAGE_SIZE));
    uvec2 tmp            = LOAD_CURRENT_ITEM(src_ptr, src_iter);
    STORE(dst_ptr, tmp_out_offset, tmp);
#else                            /* IM2COL_REDUCED_8X */
    uint tmp_out_offset = VECTOR_OFFSET(dst_iter, pos.x * uint(2) + pos.y * width + pos.z * uint(IMAGE_SIZE));
    uint tmp            = LOAD_CURRENT_ITEM(src_ptr, src_iter);
    STORE(dst_ptr, tmp_out_offset, tmp);
#endif                           /* IM2COL_REDUCED_8X */
}

#endif /* IM2COL_REDUCED_GENERIC */
#else  /* DATA_TYPE_FP32 */
#error Data type not supported
#endif /* DATA_TYPE_FP32 */
#endif /* IM2COL_REDUCED */

#ifdef COL2IM
#ifdef WIDTH_OUTPUT

/** This kernel performs a reshaping of the output of the convolution layer.
 *
 * @note The data type must be passed at compile time using "#define DATA_TYPE_FP32"
 *
 * @param[in]  src_ptr     Pointer to the source tensor. Supported data types: F16/F32
 * @param[in]  src_attrs   The attributes of the source tensor
 * @param[out] dst_ptr     Pointer to the destination tensor. Supported data types: same as @p src_ptr
 * @param[in]  dst_attrs   The attributes of the destination tensor
 * @param[in]  dst_depth   The length of the destination tensor in Z dimension
 * @param[in]  dst_strideZ The actual stride of the destination tensor in Z dimension
 */

SHADER_PARAMS_DECLARATION
{
    Tensor3DAttributes src_attrs;
    Tensor3DAttributes dst_attrs;
    uint               dst_depth;
    uint               dst_strideZ;
};

#ifdef DATA_TYPE_FP32

TENSOR_DECLARATION(1, srcBuffer, float, src_ptr, src_shift, 2, readonly);
TENSOR_DECLARATION(2, dstBuffer, float, dst_ptr, dst_shift, 2, restrict);

void main(void)
{
    Tensor3DIterator src_iter = CONVERT_TO_TENSOR3D_ITERATOR_NO_STEP(src_attrs, src_shift);
    Tensor3DIterator dst_iter = CONVERT_TO_TENSOR3D_ITERATOR(dst_attrs, dst_shift);

    uvec3 pos = uvec3(gl_GlobalInvocationID.xyz);
    TENSOR_ITERATOR_ADVANCE_IN_BYTES(src_iter, pos.x * src_attrs.step_y + pos.y * uint(WIDTH_OUTPUT) * src_attrs.step_y + (pos.z % dst_depth) * src_attrs.stride_x + (pos.z / dst_depth) * dst_strideZ);

    STORE_CURRENT_ITEM(dst_ptr, dst_iter, LOAD_CURRENT_ITEM(src_ptr, src_iter));
}

#elif defined(DATA_TYPE_FP16)

TENSOR_DECLARATION(1, srcBuffer, uint, src_ptr, src_shift, 2, readonly);
TENSOR_DECLARATION(2, dstBuffer, uint, dst_ptr, dst_shift, 2, restrict);

void main(void)
{
    Tensor3DIterator src_iter = CONVERT_TO_TENSOR3D_ITERATOR_NO_STEP(src_attrs, src_shift);
    Tensor3DIterator dst_iter = CONVERT_TO_TENSOR3D_ITERATOR(dst_attrs, dst_shift);

    uvec3 pos = uvec3(gl_GlobalInvocationID.xyz);

    if((pos.z % dst_depth) % 2u == 0u)
    {
        uint common_offset_in_bytes = pos.x * src_attrs.step_y * 2u + pos.y * uint(WIDTH_OUTPUT) * src_attrs.step_y + (pos.z % dst_depth) * src_attrs.stride_x + (pos.z / dst_depth) * dst_strideZ;
        uint tmp1_in_offset         = TENSOR_OFFSET_ADVANCE_IN_BYTES(src_iter, common_offset_in_bytes);
        uint tmp2_in_offset         = TENSOR_OFFSET_ADVANCE_IN_BYTES(src_iter, common_offset_in_bytes + src_attrs.step_y);
        vec2 tmp1                   = LOAD_UNPACK2_HALF(src_ptr, tmp1_in_offset);
        vec2 tmp2                   = LOAD_UNPACK2_HALF(src_ptr, tmp2_in_offset);
        vec2 result                 = vec2(tmp1.x, tmp2.x);
        STORE_PACK2_CURRENT_ITEM_HALF(dst_ptr, dst_iter, result);
    }
    else
    {
        uint common_offset_in_bytes = pos.x * src_attrs.step_y * 2u + pos.y * uint(WIDTH_OUTPUT) * src_attrs.step_y + (pos.z % dst_depth) * src_attrs.stride_x + (pos.z / dst_depth) * dst_strideZ - 2u;
        uint tmp1_in_offset         = TENSOR_OFFSET_ADVANCE_IN_BYTES(src_iter, common_offset_in_bytes);
        uint tmp2_in_offset         = TENSOR_OFFSET_ADVANCE_IN_BYTES(src_iter, common_offset_in_bytes + src_attrs.step_y);
        vec2 tmp1                   = LOAD_UNPACK2_HALF(src_ptr, tmp1_in_offset);
        vec2 tmp2                   = LOAD_UNPACK2_HALF(src_ptr, tmp2_in_offset);
        vec2 result                 = vec2(tmp1.y, tmp2.y);
        STORE_PACK2_CURRENT_ITEM_HALF(dst_ptr, dst_iter, result);
    }
}

#else /* DATA_TYPE_FP32 */
#error Data type not supported
#endif /* DATA_TYPE_FP32 */
#endif /* WIDTH_OUTPUT */
#endif /* COL2IM */

)"